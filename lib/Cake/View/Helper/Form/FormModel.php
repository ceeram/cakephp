<?php
class FormModel {

/**
 * FormHelper instance
 *
 * @var FormHelper
 */
	protected $_Form;

/**
 * The default model being used for the current form.
 *
 * @var string
 */
	public $defaultModel = null;

/**
 * The name of the current model entities are in scope of.
 *
 * @see Helper::setEntity()
 * @var string
 */
	protected $_modelScope;

/**
 * The dot separated list of elements the current field entity is for.
 *
 * @see Helper::setEntity()
 * @var string
 */
	protected $_entityPath;

/**
 * The name of the current model association entities are in scope of.
 *
 * @see Helper::setEntity()
 * @var string
 */
	protected $_association;

/**
 * Holds the model references already loaded by this helper
 * product of trying to inspect them out of field names
 *
 * @var array
 */
	protected $_models = array();

/**
 * Holds all the validation errors for models loaded and inspected
 * it can also be set manually to be able to display custom error messages
 * in the any of the input fields generated by this helper
 *
 * @var array
 */
	public $validationErrors = array();

/**
 * A list of strings that should be treated as suffixes, or
 * sub inputs for a parent input.  This is used for date/time
 * inputs primarily.
 *
 * @var array
 */
	protected $_fieldSuffixes = array(
		'year', 'month', 'day', 'hour', 'min', 'second', 'meridian'
	);

/**
 * Holds the fields array('field_name' => array('type' => 'string', 'length' => 100),
 * primaryKey and validates array('field_name')
 *
 * @var array
 */
	public $fieldset = array();

/**
 *
 */
	public function __construct(FormHelper $Form) {
		$this->_Form = $Form;
	}

/**
 * Gets the currently-used model field of the rendering context.
 * Strips off field suffixes such as year, month, day, hour, min, meridian
 * when the current entity is longer than 2 elements.
 *
 * @return string
 */
	public function field() {
		$entity = $this->entity();
		$count = count($entity);
		$last = $entity[$count - 1];
		if ($count > 2 && in_array($last, $this->_fieldSuffixes)) {
			$last = isset($entity[$count - 2]) ? $entity[$count - 2] : null;
		}
		return $last;
	}

/**
 * Sets this helper's model and field properties to the dot-separated value-pair in $entity.
 *
 * @param string $entity A field name, like "ModelName.fieldName" or "ModelName.ID.fieldName"
 * @param boolean $setScope Sets the view scope to the model specified in $tagValue
 * @return void
 */
	public function setEntity($entity, $setScope = false) {
		if ($entity === null) {
			$this->_modelScope = false;
		}
		if ($setScope === true) {
			$this->_modelScope = $entity;
		}
		$parts = array_values(Hash::filter(explode('.', $entity)));
		if (empty($parts)) {
			return;
		}
		$count = count($parts);
		$lastPart = isset($parts[$count - 1]) ? $parts[$count - 1] : null;

		// Either 'body' or 'date.month' type inputs.
		if (
			($count === 1 && $this->_modelScope && $setScope == false) ||
			(
				$count === 2 &&
				in_array($lastPart, $this->_fieldSuffixes) &&
				$this->_modelScope &&
				$parts[0] !== $this->_modelScope
			)
		) {
			$entity = $this->_modelScope . '.' . $entity;
		}

		// 0.name, 0.created.month style inputs.  Excludes inputs with the modelScope in them.
		if (
			$count >= 2 &&
			is_numeric($parts[0]) &&
			!is_numeric($parts[1]) &&
			$this->_modelScope &&
			strpos($entity, $this->_modelScope) === false
		) {
			$entity = $this->_modelScope . '.' . $entity;
		}

		$this->_association = null;

		$isHabtm = (
			isset($this->fieldset[$this->_modelScope]['fields'][$parts[0]]['type']) &&
			$this->fieldset[$this->_modelScope]['fields'][$parts[0]]['type'] === 'multiple' &&
			$count == 1
		);

		// habtm models are special
		if ($count == 1 && $isHabtm) {
			$this->_association = $parts[0];
			$entity = $parts[0] . '.' . $parts[0];
		} else {
			// check for associated model.
			$reversed = array_reverse($parts);
			foreach ($reversed as $i => $part) {
				if ($i > 0 && preg_match('/^[A-Z]/', $part)) {
					$this->_association = $part;
					break;
				}
			}
		}
		$this->_entityPath = $entity;
	}

/**
 * Returns the entity reference of the current context as an array of identity parts
 *
 * @return array An array containing the identity elements of an entity
 */
	public function entity() {
		return explode('.', $this->_entityPath);
	}

/**
 * Gets the currently-used model of the rendering context.
 *
 * @return string
 */
	public function model() {
		if ($this->_association) {
			return $this->_association;
		}
		return $this->_modelScope;
	}

/**
 * Gets the input field name for the current tag. Creates input name attributes
 * using CakePHP's data[Model][field] formatting.
 *
 * @param array|string $options If an array, should be an array of attributes that $key needs to be added to.
 *   If a string or null, will be used as the View entity.
 * @param string $field
 * @param string $key The name of the attribute to be set, defaults to 'name'
 * @return mixed If an array was given for $options, an array with $key set will be returned.
 *   If a string was supplied a string will be returned.
 * @todo Refactor this method to not have as many input/output options.
 */
	public function name($options = array(), $field = null, $key = 'name') {
		if ($this->_Form->requestType == 'get') {
			if ($options === null) {
				$options = array();
			} elseif (is_string($options)) {
				$field = $options;
				$options = 0;
			}

			if (!empty($field)) {
				$this->setEntity($field);
			}

			if (is_array($options) && isset($options[$key])) {
				return $options;
			}

			$entity = $this->entity();
			$model = $this->model();
			$name = $model === $entity[0] && isset($entity[1]) ? $entity[1] : $entity[0];
			$last = $entity[count($entity) - 1];
			if (in_array($last, $this->fieldSuffixes())) {
				$name .= '[' . $last . ']';
			}

			if (is_array($options)) {
				$options[$key] = $name;
				return $options;
			} else {
				return $name;
			}
		}
		if ($options === null) {
			$options = array();
		} elseif (is_string($options)) {
			$field = $options;
			$options = 0;
		}

		if (!empty($field)) {
			$this->setEntity($field);
		}

		if (is_array($options) && array_key_exists($key, $options)) {
			return $options;
		}

		switch ($field) {
			case '_method':
				$name = $field;
			break;
			default:
				$name = 'data[' . implode('][', $this->entity()) . ']';
			break;
		}

		if (is_array($options)) {
			$options[$key] = $name;
			return $options;
		} else {
			return $name;
		}
	}

/**
 * Generates a DOM ID for the selected element, if one is not set.
 * Uses the current View::entity() settings to generate a CamelCased id attribute.
 *
 * @param array|string $options Either an array of html attributes to add $id into, or a string
 *   with a view entity path to get a domId for.
 * @param string $id The name of the 'id' attribute.
 * @return mixed If $options was an array, an array will be returned with $id set.  If a string
 *   was supplied, a string will be returned.
 * @todo Refactor this method to not have as many input/output options.
 */
	public function domId($options = null, $id = 'id') {
		if (is_array($options) && array_key_exists($id, $options) && $options[$id] === null) {
			unset($options[$id]);
			return $options;
		} elseif (is_string($options)) {
			$this->setEntity($options);
			return $this->domId();
		}

		$entity = $this->entity();
		$model = array_shift($entity);
		$dom = $model . implode('', array_map(array('Inflector', 'camelize'), $entity));

		if (is_array($options) && !array_key_exists($id, $options)) {
			$options[$id] = $dom;
		} elseif ($options === null) {
			return $dom;
		}
		return $options;
	}

/**
 * Guess the location for a model based on its name and tries to create a new instance
 * or get an already created instance of the model
 *
 * @param string $model
 * @return Model model instance
 */
	protected function _getModel($model) {
		if (!$model || $model === 'Model') {
			return null;
		}

		if (array_key_exists($model, $this->_models)) {
			return $this->_models[$model];
		}

		if ($object = $this->_getObject($model)) {
			$this->_models[$model] = $object;
			$this->fieldset[$model] = array('fields' => null, 'key' => $object->primaryKey, 'validates' => null);
			return $object;
		}
	}

	protected function _getObject($model) {
		if (ClassRegistry::isKeySet($model)) {
			return ClassRegistry::getObject($model);
		}
		if (isset($this->_Form->request->params['models'][$model])) {
			$plugin = $this->_Form->request->params['models'][$model]['plugin'];
			$plugin .= ($plugin) ? '.' : null;
			return ClassRegistry::init(array(
				'class' => $plugin . $this->_Form->request->params['models'][$model]['className'],
				'alias' => $model
			));
		} elseif (ClassRegistry::isKeySet($this->defaultModel)) {
			$defaultObject = ClassRegistry::getObject($this->defaultModel);
			if ($defaultObject && in_array($model, array_keys($defaultObject->getAssociated()), true) && isset($defaultObject->{$model})) {
				return $defaultObject->{$model};
			}
			return null;
		}
		$object = ClassRegistry::init($model, true);

		if (!$object) {
			return null;
		}
		return $object;
	}
/**
 * Inspects the model properties to extract information from them.
 * Currently it can extract information from the the fields, the primary key and required fields
 *
 * The $key parameter accepts the following list of values:
 *
 * - key: Returns the name of the primary key for the model
 * - fields: Returns the model schema
 * - validates: returns the list of fields that are required
 * - errors: returns the list of validation errors
 *
 * If the $field parameter is passed if will return the information for that sole field.
 *
 * `$this->introspect('Post', 'fields', 'title');` will return the schema information for title column
 *
 * @param string $model name of the model to extract information from
 * @param string $key name of the special information key to obtain (key, fields, validates, errors)
 * @param string $field name of the model field to get information from
 * @return mixed information extracted for the special key and field in a model
 */
	public function introspect($key, $field = null) {
		$model = $this->model();
		$object = $this->_getModel($model);
		if (!$object) {
			return;
		}

		if ($key === 'key') {
			return $this->fieldset[$model]['key'] = $object->primaryKey;
		}

		if ($key === 'fields') {
			if (!isset($this->fieldset[$model]['fields'])) {
				$this->fieldset[$model]['fields'] = $object->schema();
				foreach ($object->hasAndBelongsToMany as $alias => $assocData) {
					$this->fieldset[$object->alias]['fields'][$alias] = array('type' => 'multiple');
				}
			}
			if (empty($field)) {
				return $this->fieldset[$model]['fields'];
			}
			if (isset($this->fieldset[$model]['fields'][$field])) {
				return $this->fieldset[$model]['fields'][$field];
			}
			return isset($object->hasAndBelongsToMany[$field]) ? array('type' => 'multiple') : null;
		}

		if ($key === 'errors') {
			if (!isset($this->validationErrors[$model])) {
				$this->validationErrors[$model] =& $object->validationErrors;
			}
			return $this->validationErrors[$model];
		}

		if ($key === 'validates') {
			if (!isset($this->fieldset[$model]['validates'])) {
				$validates = array();
				if (!empty($object->validate)) {
					foreach ($object->validator() as $validateField => $validateProperties) {
						if ($this->_isRequiredField($validateProperties)) {
							$validates[$validateField] = true;
						}
					}
				}
				$this->fieldset[$model]['validates'] = $validates;
			}
			if (empty($field)) {
				return $this->fieldset[$model]['validates'];
			}
			return isset($this->fieldset[$model]['validates'][$field]) ?
					$this->fieldset[$model]['validates'][$field] : null;
		}
	}

/**
 * Returns false if given form field described by the current entity has no errors.
 * Otherwise it returns the validation message
 *
 * @return mixed Either false when there are no errors, or an array of error
 *    strings. An error string could be ''.
 * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/form.html#FormHelper::tagIsInvalid
 */
	public function tagIsInvalid() {
		$entity = $this->entity();
		$model = array_shift($entity);
		$errors = array();
		if (!empty($entity) && isset($this->validationErrors[$model])) {
			$errors = $this->validationErrors[$model];
		}
		if (!empty($entity) && empty($errors)) {
			$errors = $this->introspect('errors');
		}
		if (empty($errors)) {
			return false;
		}
		$errors = Hash::get($errors, implode('.', $entity));
		return $errors === null ? false : $errors;
	}

/**
 * Returns if a field is required to be filled based on validation properties from the validating object.
 *
 * @param CakeValidationSet $validationRules
 * @return boolean true if field is required to be filled, false otherwise
 */
	protected function _isRequiredField($validationRules) {
		if (empty($validationRules) || count($validationRules) === 0) {
			return false;
		}
		foreach ($validationRules as $rule) {
			$rule->isUpdate($this->_Form->requestType === 'put');
			if ($rule->isEmptyAllowed()) {
				return false;
			}
		}
		return true;
	}

	public function fieldSuffixes() {
		return $this->_fieldSuffixes;
	}

/**
 * Returns true if there is an error for the given field, otherwise false
 *
 * @param string $field This should be "Modelname.fieldname"
 * @return boolean If there are errors this method returns true, else false.
 * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/form.html#FormHelper::isFieldError
 */
	public function isFieldError($field) {
		$this->setEntity($field);
		return (bool)$this->tagIsInvalid();
	}

/**
 * Sets the defaults for an input tag.  Will set the
 * name, value, and id attributes for an array of html attributes. Will also
 * add a 'form-error' class if the field contains validation errors.
 *
 * @param string $field The field name to initialize.
 * @param array $options Array of options to use while initializing an input field.
 * @return array Array options for the form input.
 */
	public function initInputField($field, $options = array()) {
		if ($field !== null) {
			$this->setEntity($field);
		}
		$options = (array)$options;
		$options = $this->name($options);
		$options = $this->domId($options);
		$options = $this->_Form->value($options);
		return $options;
	}
}